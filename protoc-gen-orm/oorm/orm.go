package oorm

import (
	"log"
	"sort"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	"github.com/gogo/protobuf/protoc-gen-gogo/generator"
	"protoc.yyue.dev/protoc-gen-orm/orm"
)

type Orm struct {
	*generator.Generator
	currentFile string
	fileImports *fileImports
}
type fileImports struct {
	wktPkgName      string
	typesToRegister []string
	stdImports      []string
	packages        map[string]*pkgImport
}
type pkgImport struct {
	packagePath string
	alias       string
}

// Name identifies the plugin.
func (o *Orm) Name() string {
	return "gorm"
}

func (o *Orm) setFile(file string, pkg string) {
	o.currentFile = file
	o.Generator.SetFile(file)
}

// Init is called once after data structures are built but before
// code generation begins.
func (o *Orm) Init(g *generator.Generator) {
	o.Generator = g
	o.fileImports = new(fileImports)

}

// Generate produces the code generated by the plugin for this file,
// except for the imports, by calling the generator's methods P, In, and Out.
func (o *Orm) Generate(file *generator.FileDescriptor) {

	for _, message := range file.Messages() {
		// We don't want to bother with the MapEntry stuff
		if message.GetOptions().GetMapEntry() {
			continue
		}
		if message.Options != nil {
			v, err := proto.GetExtension(message.Options, orm.E_Ormable)
			if err == nil {
				opts, ok := v.(*bool)
				if ok && *opts {
					log.Println("install: ", message.TypeName())
					// pase message
					o.P(`type `, message.TypeName()[0], `ORM struct {`)
					fields := fieldSort(message.GetField())
					sort.Sort(fields)
					for _, field := range fields {
						fieldType := o.getFieldType(message, field)
						fieldName := generator.CamelCase(field.GetName())
						log.Println("install: ", field)
						if fieldType != "" {
							o.P(fieldName, ` `, fieldType, o.renderGormTag(fieldName))
						}
					}
					o.P(`}`)
				}
			}
		}

	}
}

// GenerateImports produces the import declarations for this file.
// It is called after Generate.
func (o *Orm) GenerateImports(file *generator.FileDescriptor) {
	imports := o.fileImports
	for _, typeName := range imports.typesToRegister {
		o.RecordTypeUse(typeName)
	}
	githubImports := imports.packages
	sort.Strings(imports.stdImports)
	for _, dep := range imports.stdImports {
		o.PrintImport(generator.GoPackageName(dep), generator.GoImportPath(dep))
	}
	o.P()
	aliases := []string{}
	for a := range githubImports {
		aliases = append(aliases, a)
	}
	sort.Strings(aliases)
	for _, a := range aliases {
		o.PrintImport(generator.GoPackageName(a), generator.GoImportPath(githubImports[a].packagePath))
	}
	o.P()
}

func (o *Orm) parseMessage() {

}

func (o *Orm) getSortedFieldNames() {
}

type fieldSort []*descriptor.FieldDescriptorProto

// Len is the number of elements in the collection.
func (f fieldSort) Len() int {
	return len(f)
}

// Less reports whether the element with index i
// must sort before the element with index j.
//
// If both Less(i, j) and Less(j, i) are false,
// then the elements at index i and j are considered equal.
// Sort may place equal elements in any order in the final result,
// while Stable preserves the original input order of equal elements.
//
// Less must describe a transitive ordering:
//  - if both Less(i, j) and Less(j, k) are true, then Less(i, k) must be true as well.
//  - if both Less(i, j) and Less(j, k) are false, then Less(i, k) must be false as well.
//
// Note that floating-point comparison (the < operator on float32 or float64 values)
// is not a transitive ordering when not-a-number (NaN) values are involved.
// See Float64Slice.Less for a correct implementation for floating-point values.
func (f fieldSort) Less(i int, j int) bool {
	sortStrs := []string{"CreatedAt", "UpdatedAt", "DeletedAt"}
	ii := generator.CamelCase(f[i].GetName())
	jj := generator.CamelCase(f[j].GetName())
	if ii == "ID" {
		return true
	}
	if jj == "ID" {
		return false
	}
	return SliceIndex(sortStrs, ii) < SliceIndex(sortStrs, jj)
}

// Swap swaps the elements with indexes i and j.
func (f fieldSort) Swap(i int, j int) {
	f[i], f[j] = f[j], f[i]
}

func SliceIndex(strs []string, str string) int {
	for i, s := range strs {
		if s == str {
			return i
		}
	}
	return -1
}

func (o *Orm) renderGormTag(fieldName string) string {
	if fieldName == "ID" {
		return "`gorm:\"primary_key\";`"
	}
	if fieldName == "DeletedAt" {
		return "`gorm:\"index\";`"
	}
	return ""
}

var wellKnownTypes = map[string]string{
	"StringValue": "*string",
	"DoubleValue": "*float64",
	"FloatValue":  "*float32",
	"Int32Value":  "*int32",
	"Int64Value":  "*int64",
	"UInt32Value": "*uint32",
	"UInt64Value": "*uint64",
	"BoolValue":   "*bool",
	//  "BytesValue" : "*[]byte",
}

func (o *Orm) getFieldType(message *generator.Descriptor, field *descriptor.FieldDescriptorProto) string {
	fieldType, _ := o.GoType(message, field)
	isMessage := *(field.Type) == descriptor.FieldDescriptorProto_TYPE_MESSAGE
	if (!isMessage) && field.IsRepeated() {
		// TODO: 未实现
		return ""
	} else if *(field.Type) == descriptor.FieldDescriptorProto_TYPE_ENUM {
		fieldType = "int32"
		if strings.EqualFold(o.Param["enums"], "string") {
			fieldType = "string"
		}
	} else if isMessage {
		log.Println("isMessage fieldType", fieldType)
		if fieldType == "*timestamppb.Timestamp" {
			o.UsingGoImports("time")
			fieldType = "*time.Time"
		} else {
			return ""
		}
	}
	return fieldType
}

// UsingGoImports should be used with basic packages like "time", or "context"
func (o *Orm) UsingGoImports(pkgNames ...string) {
	o.GetFileImports().stdImports = append(o.GetFileImports().stdImports, pkgNames...)
}

func newFileImports() *fileImports {
	return &fileImports{packages: make(map[string]*pkgImport)}
}

func (o *Orm) GetFileImports() *fileImports {
	return o.fileImports
}
