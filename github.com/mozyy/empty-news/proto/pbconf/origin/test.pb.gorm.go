// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protoc-gen-orm/test.proto

package pbconf

import (
	context "context"
	fmt "fmt"
	
	_ "github.com/infobloxopen/protoc-gen-gorm/options"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	math "math"
	strings "strings"
	time "time"

	ptypes1 "github.com/golang/protobuf/ptypes"
	gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm1 "github.com/jinzhu/gorm"
	field_mask1 "google.golang.org/genproto/protobuf/field_mask"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type ConfigORM struct {
	Content   string
	CreatedAt *time.Time
	DeletedAt *time.Time
	Desc      string
	Id        uint32 `gorm:"primary_key"`
	Type      string
	UpdatedAt *time.Time
	Value     string
}

// TableName overrides the default tablename generated by GORM
func (ConfigORM) TableName() string {
	return "configs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Config) ToORM(ctx context.Context) (ConfigORM, error) {
	to := ConfigORM{}
	var err error
	if prehook, ok := interface{}(m).(ConfigWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	to.Type = m.Type
	to.Value = m.Value
	to.Content = m.Content
	to.Desc = m.Desc
	if posthook, ok := interface{}(m).(ConfigWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ConfigORM) ToPB(ctx context.Context) (Config, error) {
	to := Config{}
	var err error
	if prehook, ok := interface{}(m).(ConfigWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	to.Type = m.Type
	to.Value = m.Value
	to.Content = m.Content
	to.Desc = m.Desc
	if posthook, ok := interface{}(m).(ConfigWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Config the arg will be the target, the caller the one being converted from

// ConfigBeforeToORM called before default ToORM code
type ConfigWithBeforeToORM interface {
	BeforeToORM(context.Context, *ConfigORM) error
}

// ConfigAfterToORM called after default ToORM code
type ConfigWithAfterToORM interface {
	AfterToORM(context.Context, *ConfigORM) error
}

// ConfigBeforeToPB called before default ToPB code
type ConfigWithBeforeToPB interface {
	BeforeToPB(context.Context, *Config) error
}

// ConfigAfterToPB called after default ToPB code
type ConfigWithAfterToPB interface {
	AfterToPB(context.Context, *Config) error
}

type DeleteTypeORM struct {
	Id uint32
}

// TableName overrides the default tablename generated by GORM
func (DeleteTypeORM) TableName() string {
	return "delete_types"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *DeleteType) ToORM(ctx context.Context) (DeleteTypeORM, error) {
	to := DeleteTypeORM{}
	var err error
	if prehook, ok := interface{}(m).(DeleteTypeWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if posthook, ok := interface{}(m).(DeleteTypeWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DeleteTypeORM) ToPB(ctx context.Context) (DeleteType, error) {
	to := DeleteType{}
	var err error
	if prehook, ok := interface{}(m).(DeleteTypeWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if posthook, ok := interface{}(m).(DeleteTypeWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type DeleteType the arg will be the target, the caller the one being converted from

// DeleteTypeBeforeToORM called before default ToORM code
type DeleteTypeWithBeforeToORM interface {
	BeforeToORM(context.Context, *DeleteTypeORM) error
}

// DeleteTypeAfterToORM called after default ToORM code
type DeleteTypeWithAfterToORM interface {
	AfterToORM(context.Context, *DeleteTypeORM) error
}

// DeleteTypeBeforeToPB called before default ToPB code
type DeleteTypeWithBeforeToPB interface {
	BeforeToPB(context.Context, *DeleteType) error
}

// DeleteTypeAfterToPB called after default ToPB code
type DeleteTypeWithAfterToPB interface {
	AfterToPB(context.Context, *DeleteType) error
}

// DefaultCreateConfig executes a basic gorm create call
func DefaultCreateConfig(ctx context.Context, in *Config, db *gorm1.DB) (*Config, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ConfigORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ConfigORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ConfigORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ConfigORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadConfig executes a basic gorm read call
func DefaultReadConfig(ctx context.Context, in *Config, db *gorm1.DB) (*Config, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ConfigORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ConfigORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ConfigORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ConfigORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ConfigORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ConfigORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ConfigORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ConfigORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteConfig(ctx context.Context, in *Config, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ConfigORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ConfigORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ConfigORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ConfigORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ConfigORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteConfigSet(ctx context.Context, in []*Config, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ConfigORM{})).(ConfigORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ConfigORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ConfigORM{})).(ConfigORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ConfigORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Config, *gorm1.DB) (*gorm1.DB, error)
}
type ConfigORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Config, *gorm1.DB) error
}

// DefaultStrictUpdateConfig clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateConfig(ctx context.Context, in *Config, db *gorm1.DB) (*Config, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateConfig")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ConfigORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ConfigORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ConfigORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ConfigORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ConfigORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ConfigORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ConfigORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchConfig executes a basic gorm update call with patch behavior
func DefaultPatchConfig(ctx context.Context, in *Config, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Config, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Config
	var err error
	if hook, ok := interface{}(&pbObj).(ConfigWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadConfig(ctx, &Config{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ConfigWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskConfig(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ConfigWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateConfig(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ConfigWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ConfigWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Config, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ConfigWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Config, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ConfigWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Config, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ConfigWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Config, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetConfig executes a bulk gorm update call with patch behavior
func DefaultPatchSetConfig(ctx context.Context, objects []*Config, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Config, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Config, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchConfig(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskConfig patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskConfig(ctx context.Context, patchee *Config, patcher *Config, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Config, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Value" {
			patchee.Value = patcher.Value
			continue
		}
		if f == prefix+"Content" {
			patchee.Content = patcher.Content
			continue
		}
		if f == prefix+"Desc" {
			patchee.Desc = patcher.Desc
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListConfig executes a gorm list call
func DefaultListConfig(ctx context.Context, db *gorm1.DB) ([]*Config, error) {
	in := Config{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ConfigORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ConfigORM{}, &Config{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ConfigORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ConfigORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ConfigORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Config{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ConfigORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ConfigORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ConfigORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ConfigORM) error
}

// DefaultCreateDeleteType executes a basic gorm create call
func DefaultCreateDeleteType(ctx context.Context, in *DeleteType, db *gorm1.DB) (*DeleteType, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeleteTypeORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeleteTypeORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DeleteTypeORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DeleteTypeORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadDeleteType executes a basic gorm read call
func DefaultReadDeleteType(ctx context.Context, in *DeleteType, db *gorm1.DB) (*DeleteType, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DeleteTypeORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &DeleteTypeORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeleteTypeORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := DeleteTypeORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(DeleteTypeORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type DeleteTypeORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DeleteTypeORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DeleteTypeORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteDeleteType(ctx context.Context, in *DeleteType, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DeleteTypeORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&DeleteTypeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(DeleteTypeORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type DeleteTypeORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DeleteTypeORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteDeleteTypeSet(ctx context.Context, in []*DeleteType, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&DeleteTypeORM{})).(DeleteTypeORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&DeleteTypeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&DeleteTypeORM{})).(DeleteTypeORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type DeleteTypeORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*DeleteType, *gorm1.DB) (*gorm1.DB, error)
}
type DeleteTypeORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*DeleteType, *gorm1.DB) error
}

// DefaultStrictUpdateDeleteType clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateDeleteType(ctx context.Context, in *DeleteType, db *gorm1.DB) (*DeleteType, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateDeleteType")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &DeleteTypeORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(DeleteTypeORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DeleteTypeORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeleteTypeORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type DeleteTypeORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DeleteTypeORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DeleteTypeORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchDeleteType executes a basic gorm update call with patch behavior
func DefaultPatchDeleteType(ctx context.Context, in *DeleteType, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*DeleteType, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj DeleteType
	var err error
	if hook, ok := interface{}(&pbObj).(DeleteTypeWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadDeleteType(ctx, &DeleteType{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(DeleteTypeWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskDeleteType(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(DeleteTypeWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateDeleteType(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(DeleteTypeWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type DeleteTypeWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *DeleteType, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type DeleteTypeWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *DeleteType, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type DeleteTypeWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *DeleteType, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type DeleteTypeWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *DeleteType, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetDeleteType executes a bulk gorm update call with patch behavior
func DefaultPatchSetDeleteType(ctx context.Context, objects []*DeleteType, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*DeleteType, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*DeleteType, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchDeleteType(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskDeleteType patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDeleteType(ctx context.Context, patchee *DeleteType, patcher *DeleteType, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*DeleteType, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDeleteType executes a gorm list call
func DefaultListDeleteType(ctx context.Context, db *gorm1.DB) ([]*DeleteType, error) {
	in := DeleteType{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeleteTypeORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &DeleteTypeORM{}, &DeleteType{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeleteTypeORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []DeleteTypeORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeleteTypeORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*DeleteType{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DeleteTypeORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DeleteTypeORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DeleteTypeORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]DeleteTypeORM) error
}
type ConfDefaultServer struct {
	DB *gorm1.DB
}

// Create ...
func (m *ConfDefaultServer) Create(ctx context.Context, in *CreateRequest) (*CreateResponse, error) {
	out := &CreateResponse{}
	return out, nil
}

// Update ...
func (m *ConfDefaultServer) Update(ctx context.Context, in *CreateRequest) (*CreateResponse, error) {
	out := &CreateResponse{}
	return out, nil
}

// Read ...
func (m *ConfDefaultServer) Read(ctx context.Context, in *ReadRequest) (*CreateResponse, error) {
	out := &CreateResponse{}
	return out, nil
}

// List ...
func (m *ConfDefaultServer) List(ctx context.Context, in *ListRequest) (*ListResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ConfConfigWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListConfig(ctx, db)
	if err != nil {
		return nil, err
	}
	out := &ListResponse{Results: res}
	if custom, ok := interface{}(in).(ConfConfigWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ConfConfigWithBeforeList called before DefaultListConfig in the default List handler
type ConfConfigWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ConfConfigWithAfterList called before DefaultListConfig in the default List handler
type ConfConfigWithAfterList interface {
	AfterList(context.Context, *ListResponse, *gorm1.DB) error
}

// Delete ...
func (m *ConfDefaultServer) Delete(ctx context.Context, in *DeleteRequest) (*emptypb.Empty, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ConfConfigWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteConfig(ctx, &Config{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &emptypb.Empty{}
	if custom, ok := interface{}(in).(ConfConfigWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ConfConfigWithBeforeDelete called before DefaultDeleteConfig in the default Delete handler
type ConfConfigWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ConfConfigWithAfterDelete called before DefaultDeleteConfig in the default Delete handler
type ConfConfigWithAfterDelete interface {
	AfterDelete(context.Context, *emptypb.Empty, *gorm1.DB) error
}

// Custom ...
func (m *ConfDefaultServer) Custom(ctx context.Context, in *DeleteRequest) (*emptypb.Empty, error) {
	out := &emptypb.Empty{}
	return out, nil
}

type ConfDefaultServer struct {
	DB *gorm1.DB
}

// Create ...
func (m *ConfDefaultServer) Create(ctx context.Context, in *CreateRequest) (*CreateResponse, error) {
	out := &CreateResponse{}
	return out, nil
}

// Update ...
func (m *ConfDefaultServer) Update(ctx context.Context, in *CreateRequest) (*CreateResponse, error) {
	out := &CreateResponse{}
	return out, nil
}

// Read ...
func (m *ConfDefaultServer) Read(ctx context.Context, in *ReadRequest) (*CreateResponse, error) {
	out := &CreateResponse{}
	return out, nil
}

// List ...
func (m *ConfDefaultServer) List(ctx context.Context, in *ListRequest) (*ListResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ConfConfigWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListConfig(ctx, db)
	if err != nil {
		return nil, err
	}
	out := &ListResponse{Results: res}
	if custom, ok := interface{}(in).(ConfConfigWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ConfConfigWithBeforeList called before DefaultListConfig in the default List handler
type ConfConfigWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ConfConfigWithAfterList called before DefaultListConfig in the default List handler
type ConfConfigWithAfterList interface {
	AfterList(context.Context, *ListResponse, *gorm1.DB) error
}

// Delete ...
func (m *ConfDefaultServer) Delete(ctx context.Context, in *DeleteRequest) (*emptypb.Empty, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ConfConfigWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteConfig(ctx, &Config{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &emptypb.Empty{}
	if custom, ok := interface{}(in).(ConfConfigWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ConfConfigWithBeforeDelete called before DefaultDeleteConfig in the default Delete handler
type ConfConfigWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ConfConfigWithAfterDelete called before DefaultDeleteConfig in the default Delete handler
type ConfConfigWithAfterDelete interface {
	AfterDelete(context.Context, *emptypb.Empty, *gorm1.DB) error
}

// Custom ...
func (m *ConfDefaultServer) Custom(ctx context.Context, in *DeleteRequest) (*emptypb.Empty, error) {
	out := &emptypb.Empty{}
	return out, nil
}

type ConfDefaultServer struct {
	DB *gorm1.DB
}

// Create ...
func (m *ConfDefaultServer) Create(ctx context.Context, in *CreateRequest) (*CreateResponse, error) {
	out := &CreateResponse{}
	return out, nil
}

// Update ...
func (m *ConfDefaultServer) Update(ctx context.Context, in *CreateRequest) (*CreateResponse, error) {
	out := &CreateResponse{}
	return out, nil
}

// Read ...
func (m *ConfDefaultServer) Read(ctx context.Context, in *ReadRequest) (*CreateResponse, error) {
	out := &CreateResponse{}
	return out, nil
}

// List ...
func (m *ConfDefaultServer) List(ctx context.Context, in *ListRequest) (*ListResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ConfConfigWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListConfig(ctx, db)
	if err != nil {
		return nil, err
	}
	out := &ListResponse{Results: res}
	if custom, ok := interface{}(in).(ConfConfigWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ConfConfigWithBeforeList called before DefaultListConfig in the default List handler
type ConfConfigWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ConfConfigWithAfterList called before DefaultListConfig in the default List handler
type ConfConfigWithAfterList interface {
	AfterList(context.Context, *ListResponse, *gorm1.DB) error
}

// Delete ...
func (m *ConfDefaultServer) Delete(ctx context.Context, in *DeleteRequest) (*emptypb.Empty, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ConfConfigWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteConfig(ctx, &Config{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &emptypb.Empty{}
	if custom, ok := interface{}(in).(ConfConfigWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ConfConfigWithBeforeDelete called before DefaultDeleteConfig in the default Delete handler
type ConfConfigWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ConfConfigWithAfterDelete called before DefaultDeleteConfig in the default Delete handler
type ConfConfigWithAfterDelete interface {
	AfterDelete(context.Context, *emptypb.Empty, *gorm1.DB) error
}

// Custom ...
func (m *ConfDefaultServer) Custom(ctx context.Context, in *DeleteRequest) (*emptypb.Empty, error) {
	out := &emptypb.Empty{}
	return out, nil
}

type ConfDefaultServer struct {
	DB *gorm1.DB
}

// Create ...
func (m *ConfDefaultServer) Create(ctx context.Context, in *CreateRequest) (*CreateResponse, error) {
	out := &CreateResponse{}
	return out, nil
}

// Update ...
func (m *ConfDefaultServer) Update(ctx context.Context, in *CreateRequest) (*CreateResponse, error) {
	out := &CreateResponse{}
	return out, nil
}

// Read ...
func (m *ConfDefaultServer) Read(ctx context.Context, in *ReadRequest) (*CreateResponse, error) {
	out := &CreateResponse{}
	return out, nil
}

// List ...
func (m *ConfDefaultServer) List(ctx context.Context, in *ListRequest) (*ListResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ConfConfigWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListConfig(ctx, db)
	if err != nil {
		return nil, err
	}
	out := &ListResponse{Results: res}
	if custom, ok := interface{}(in).(ConfConfigWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ConfConfigWithBeforeList called before DefaultListConfig in the default List handler
type ConfConfigWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ConfConfigWithAfterList called before DefaultListConfig in the default List handler
type ConfConfigWithAfterList interface {
	AfterList(context.Context, *ListResponse, *gorm1.DB) error
}

// Delete ...
func (m *ConfDefaultServer) Delete(ctx context.Context, in *DeleteRequest) (*emptypb.Empty, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ConfConfigWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteConfig(ctx, &Config{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &emptypb.Empty{}
	if custom, ok := interface{}(in).(ConfConfigWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ConfConfigWithBeforeDelete called before DefaultDeleteConfig in the default Delete handler
type ConfConfigWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ConfConfigWithAfterDelete called before DefaultDeleteConfig in the default Delete handler
type ConfConfigWithAfterDelete interface {
	AfterDelete(context.Context, *emptypb.Empty, *gorm1.DB) error
}

// Custom ...
func (m *ConfDefaultServer) Custom(ctx context.Context, in *DeleteRequest) (*emptypb.Empty, error) {
	out := &emptypb.Empty{}
	return out, nil
}

type ConfDefaultServer struct {
	DB *gorm1.DB
}

// Create ...
func (m *ConfDefaultServer) Create(ctx context.Context, in *CreateRequest) (*CreateResponse, error) {
	out := &CreateResponse{}
	return out, nil
}

// Update ...
func (m *ConfDefaultServer) Update(ctx context.Context, in *CreateRequest) (*CreateResponse, error) {
	out := &CreateResponse{}
	return out, nil
}

// Read ...
func (m *ConfDefaultServer) Read(ctx context.Context, in *ReadRequest) (*CreateResponse, error) {
	out := &CreateResponse{}
	return out, nil
}

// List ...
func (m *ConfDefaultServer) List(ctx context.Context, in *ListRequest) (*ListResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ConfConfigWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListConfig(ctx, db)
	if err != nil {
		return nil, err
	}
	out := &ListResponse{Results: res}
	if custom, ok := interface{}(in).(ConfConfigWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ConfConfigWithBeforeList called before DefaultListConfig in the default List handler
type ConfConfigWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ConfConfigWithAfterList called before DefaultListConfig in the default List handler
type ConfConfigWithAfterList interface {
	AfterList(context.Context, *ListResponse, *gorm1.DB) error
}

// Delete ...
func (m *ConfDefaultServer) Delete(ctx context.Context, in *DeleteRequest) (*emptypb.Empty, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ConfConfigWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteConfig(ctx, &Config{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &emptypb.Empty{}
	if custom, ok := interface{}(in).(ConfConfigWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ConfConfigWithBeforeDelete called before DefaultDeleteConfig in the default Delete handler
type ConfConfigWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ConfConfigWithAfterDelete called before DefaultDeleteConfig in the default Delete handler
type ConfConfigWithAfterDelete interface {
	AfterDelete(context.Context, *emptypb.Empty, *gorm1.DB) error
}

// Custom ...
func (m *ConfDefaultServer) Custom(ctx context.Context, in *DeleteRequest) (*emptypb.Empty, error) {
	out := &emptypb.Empty{}
	return out, nil
}
